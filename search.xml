<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>22.Inline_Hook</title>
      <link href="/2024/10/10/Inline-Hook/"/>
      <url>/2024/10/10/Inline-Hook/</url>
      
        <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><hr><p>根据上节课IAT HOOK结尾的局限性分析，自己写的函数，或者是通过LoadLibrary进来的函数在IAT 表中都是不存在的。这时候我们就需要用到Inline HOOK</p><p>Inline HOOK(内联HOOK)，CE工具中的代码注入用到的就是这种HOOK。原理就是，在HOOK点修改指令，跳转到我们的函数位置，然后此时就可以获取到寄存器，堆栈信息。执行完我们自己的代码后再跳转回到原来的位置执行。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><hr><p>在制作Inline hook的过程中有不少需要注意的地方：</p><ol><li>当我们在跳转的时候可以用E8(Call),E9(Jmp)这些后面跟的地址都是需要通过公式计算的。公式：X &#x3D; 要跳转到的地址 - 5 - 当前地址（X就是跳转指令后面的值）</li><li>当我们HOOK插入跳转指令的时候会修改掉一些指令，但是当前函数还没有执行这几条指令，所以在我们的函数执行完成之前还得调用回这几条指令</li><li>当我们跳转到我们自己的函数区域时可能会对堆栈、寄存器做修改，这时候就得在执行这些操作之前保存寄存器的值，在完成操作后恢复寄存器和堆栈</li><li>这里还有一个要注意的地方就是想要直接获取到自定义函数的函数首地址不能直接用函数名，这里有个坑是这样的，当我们在调试过程中进入函数名的地址中时我们会发现这里不是函数所在的地方，而是一个jmp，跳转到函数的首地址。我们来验证一下这个观点：<br>自定义一个函数，然后调试-&gt;转到反汇编，看看函数地址：<br><img src="/./../images/QQ_1728487761135.png" alt="QQ_1728487761135"><br>此时的函数地址时413660,我们再看看<code>DWORD tmp = (DWORD)函数地址</code>是什么个东西，诶？这个tmp它不是首地址，那他是个啥咧？：<br><img src="/./../images/QQ_1728488276708.png" alt="QQ_1728488276708"></li></ol><p>我们直接启动调试，然后在反汇编窗口直接跳到这个位置，发现这里是一个jmp，而jmp的地址就是函数的首地址</p><p><img src="/./../images/QQ_1728487845633.png" alt="QQ_1728487845633"></p><h6 id="大致流程："><a href="#大致流程：" class="headerlink" title="大致流程："></a>大致流程：</h6><p><img src="/./../images/1231.png" alt="1231"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><hr><p>Main.cpp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IAT_Hook.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;InlineHOOK.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">Test_IAT_HOOK</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DWORD RetAddr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">REGISTER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DWORD EAX;</span><br><span class="line">DWORD EBX;</span><br><span class="line">DWORD ECX;</span><br><span class="line">DWORD EDX;</span><br><span class="line">DWORD EBP;</span><br><span class="line">DWORD ESP;</span><br><span class="line">DWORD ESI;</span><br><span class="line">DWORD EDI;</span><br><span class="line">&#125;Register;</span><br><span class="line"></span><br><span class="line">DWORD dwParaX;</span><br><span class="line">DWORD dwParaY;</span><br><span class="line">Register reg = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">CHAR szBuffer[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// naked裸函数，堆栈平衡要自己写</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(naked)<span class="type">void</span> <span class="title function_">HookProc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 保存寄存器</span></span><br><span class="line">_asm</span><br><span class="line">&#123;</span><br><span class="line">pushad</span><br><span class="line">pushfd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_asm</span><br><span class="line">&#123;</span><br><span class="line">mov reg.EAX, eax</span><br><span class="line">mov reg.EBX, ebx</span><br><span class="line">mov reg.ECX, ecx</span><br><span class="line">mov reg.EDX, edx</span><br><span class="line">mov reg.ESP, esp</span><br><span class="line">mov reg.EBP, ebp</span><br><span class="line">mov reg.ESI, esi</span><br><span class="line">mov reg.EDI, edi</span><br><span class="line"></span><br><span class="line">mov EAX, DWORD PTR SS : [ESP + <span class="number">0x28</span>]</span><br><span class="line">mov dwParaX, EAX</span><br><span class="line">mov EAX, DWORD PTR SS : [ESP + <span class="number">0x2C</span>]</span><br><span class="line">mov dwParaY, EAX</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sprintf</span>(szBuffer, <span class="string">&quot;EAX:%x\nEBX:%x\nECX:%x\nEDX:%x\nESP:%x\nEBP:%x\nESI:%x\nEDI:%x\n&quot;</span>, reg.EAX, reg.EBX, reg.ECX, reg.EDX, reg.ESP, reg.EBP, reg.ESI, reg.EDI);</span><br><span class="line">MessageBoxA(<span class="literal">NULL</span>, szBuffer, <span class="string">&quot;[Register]&quot;</span>, MB_OK);</span><br><span class="line"><span class="built_in">memset</span>(szBuffer, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(szBuffer, <span class="string">&quot;dwParaX: %d\ndwParaY: %d\n&quot;</span>, dwParaX, dwParaY);</span><br><span class="line">MessageBoxA(<span class="literal">NULL</span>, szBuffer, <span class="string">&quot;[参数]&quot;</span>, MB_OK);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还原现场</span></span><br><span class="line">_asm</span><br><span class="line">&#123;</span><br><span class="line">popfd</span><br><span class="line">popad</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行被删除的代码</span></span><br><span class="line">_asm</span><br><span class="line">&#123;</span><br><span class="line">push        ebp</span><br><span class="line">mov         ebp, esp</span><br><span class="line">sub         esp, <span class="number">0</span>C0h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转回去</span></span><br><span class="line">_asm</span><br><span class="line">&#123;</span><br><span class="line">jmp RetAddr</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//Test_IAT_HOOK();</span></span><br><span class="line">DWORD HookAddr = *(PDWORD)((DWORD)plus + <span class="number">1</span>) + (DWORD)plus + <span class="number">5</span>;</span><br><span class="line">RetAddr = SetInlineHOOK(HookAddr, (DWORD)HookProc, <span class="number">9</span>);</span><br><span class="line"><span class="type">int</span> x = plus(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InlineHook.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">plus</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=========================================</span></span><br><span class="line"><span class="comment">// 函数功能：设置HOOK</span></span><br><span class="line"><span class="comment">// dwHookAddr: HOOK点地址</span></span><br><span class="line"><span class="comment">// dwProcAddr   : HOOK函数地址</span></span><br><span class="line"><span class="comment">// dwLength: 修改的指令所需的长度</span></span><br><span class="line"><span class="comment">//=========================================</span></span><br><span class="line">DWORD <span class="title function_">SetInlineHOOK</span><span class="params">(DWORD dwHookAddr, DWORD dwProcAddr, DWORD dwLength)</span>;</span><br></pre></td></tr></table></figure><p>InlineHook.cpp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;InlineHOOK.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">DWORD g_dwHookAddr;<span class="comment">// HOOK开始的地址</span></span><br><span class="line">DWORD g_dwRetAddr;<span class="comment">// HOOK返回到的地址</span></span><br><span class="line">PBYTE g_pCodePatch;<span class="comment">// 存放被HOOK的内存原来的代码</span></span><br><span class="line">DWORD g_dwLength;<span class="comment">// HOOK的字节数</span></span><br><span class="line">DWORD g_dwHookFlag;<span class="comment">// HOOK状态：1表示成功 0表示失败</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DWORD <span class="title function_">SetInlineHOOK</span><span class="params">(DWORD dwHookAddr, DWORD dwProcAddr, DWORD dwLength)</span></span><br><span class="line">&#123;</span><br><span class="line">BOOL bRet = FALSE;</span><br><span class="line">DWORD dwOldProctect;</span><br><span class="line">DWORD dwJmpCode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数校验</span></span><br><span class="line"><span class="keyword">if</span> (dwHookAddr == <span class="literal">NULL</span> || dwProcAddr == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;SetInlineHook失败: HOOK地址/HOOK函数地址填写错误!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HOOK字节数不能小于5个字节</span></span><br><span class="line"><span class="keyword">if</span> (dwLength &lt; <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;HOOK字节数小于5，无法修改指令&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bRet = VirtualProtectEx(::GetCurrentProcess(), (LPVOID)dwHookAddr, dwLength, PAGE_EXECUTE_READWRITE, &amp;dwOldProctect);</span><br><span class="line"><span class="keyword">if</span> (!bRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;内存权限申请失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请一个堆空间放置HOOK前的内存代码</span></span><br><span class="line">g_pCodePatch = new BYTE[dwLength];</span><br><span class="line"><span class="built_in">memcpy</span>(g_pCodePatch, (PDWORD)dwHookAddr, dwLength);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将HOOK点的代码全部修改成nop</span></span><br><span class="line">dwJmpCode = dwProcAddr - <span class="number">5</span> - dwHookAddr;</span><br><span class="line"><span class="built_in">memset</span>((PVOID)dwHookAddr, <span class="number">0x90</span>, dwLength);</span><br><span class="line">*(PBYTE)dwHookAddr = <span class="number">0xE9</span>;</span><br><span class="line">*(PDWORD)(dwHookAddr + <span class="number">1</span>) = dwJmpCode;</span><br><span class="line"></span><br><span class="line">g_dwHookAddr = dwHookAddr;</span><br><span class="line">g_dwRetAddr = dwHookAddr + dwLength;</span><br><span class="line">g_dwLength = dwLength;</span><br><span class="line">g_dwHookFlag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> g_dwRetAddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">plus</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 滴水三期 </category>
          
          <category> win32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滴水三期 </tag>
            
            <tag> win32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21.IAT_HOOK</title>
      <link href="/2024/10/07/IAT-HOOK/"/>
      <url>/2024/10/07/IAT-HOOK/</url>
      
        <content type="html"><![CDATA[<h4 id="HOOK"><a href="#HOOK" class="headerlink" title="HOOK"></a>HOOK</h4><hr><p>HOOK这个名词根据普遍的说法是勾子，是一种编程机制。当程序执行到HOOK的时候，预先挂上的勾子(HOOK)是什么就执行什么</p><h6 id="用HOOK的目的，或者说是作用："><a href="#用HOOK的目的，或者说是作用：" class="headerlink" title="用HOOK的目的，或者说是作用："></a>用HOOK的目的，或者说是作用：</h6><ol><li>监控</li><li>修改某些行为</li></ol><blockquote><p>监控：可以通过HOOK来找到函数参数，返回值等信息</p></blockquote><blockquote><p>修改某些行为：可以用HOOK修改某些API的逻辑过程</p></blockquote><h4 id="IAT-HOOK"><a href="#IAT-HOOK" class="headerlink" title="IAT HOOK"></a>IAT HOOK</h4><hr><p>IAT HOOK是什么？在进程加载时系统会将IAT表初始化，将里面的数据替换成函数地址(例如MessageBox)。这时我们就可以将我们自己写的函数的地址替换掉原来IAT表的地址，让程序调用MessageBox时执行我们自己定义的流程。而这个自定义函数也是有要求的，他的参数想要和原来函数的参数一样，否则调用时会错误。</p><h6 id="那为什么能通过这种方式HOOK呢？"><a href="#那为什么能通过这种方式HOOK呢？" class="headerlink" title="那为什么能通过这种方式HOOK呢？"></a>那为什么能通过这种方式HOOK呢？</h6><p>我们来观察一下调用这个MessageBox时的反汇编：<br><img src="/./../images/QQ_1728217489101.png" alt="QQ_1728217489101"><br>这里是个<code>call [00FBC09C]</code> 是个间接call，我们用内存去看看FBC09C里面是什么<br><img src="/./../images/QQ_1728218233120.png" alt="QQ_1728218233120"><br>这是个值：75bfb1d0，那我们继续单步，直接步入这个call中<br><img src="/./../images/QQ_1728218330836.png" alt="QQ_1728218330836"></p><p>直接就跳到这个地址了，根据经验这个就是MessageBox的领空，所以<code>[00FBC09C]</code>存的是MessageBox的地址，而这个地址在进程加载的时候会被写进IAT表中，当我们调用函数时就通过间接call来到这个地址调用函数。所以我们在IAT表加载完成后将里面的值改成我们自己函数的地址就能实现IAT HOOK</p><h6 id="IAT-HOOK实践作用："><a href="#IAT-HOOK实践作用：" class="headerlink" title="IAT HOOK实践作用："></a>IAT HOOK实践作用：</h6><p>比原函数多出一些自己想要的操作，举一个最典型的例子，一些杀毒软件经常会在一些函数上面HOOK，做出一些检测监控的操作，监控函数的返回值，参数。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><hr><p>Main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IAT_Hook.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;Before Hook&quot;</span>, MB_OK);</span><br><span class="line"><span class="built_in">Set_IAT_HOOK</span>();</span><br><span class="line"><span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;Second test&quot;</span>, <span class="string">&quot;After HOOK&quot;</span>, MB_OK);</span><br><span class="line"><span class="built_in">UnIATHOOK</span>();</span><br><span class="line"><span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;UnIATHOOK Success&quot;</span>, <span class="string">&quot;Good&quot;</span>, MB_OK);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IAT_Hook.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IAT_Hook.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新旧函数的地址</span></span><br><span class="line">PDWORD dwOldAddress;</span><br><span class="line">PDWORD dwNewAddress;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取目录表信息</span></span><br><span class="line">HMODULE hImageBase = <span class="built_in">GetModuleHandle</span>(<span class="literal">NULL</span>);</span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)hImageBase;</span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)((DWORD)hImageBase + pDos-&gt;e_lfanew);</span><br><span class="line">PIMAGE_FILE_HEADER pFile = (PIMAGE_FILE_HEADER)((DWORD)pNt + <span class="number">4</span>);</span><br><span class="line">PIMAGE_OPTIONAL_HEADER pOpt = (PIMAGE_OPTIONAL_HEADER)((DWORD)pFile + <span class="number">20</span>);</span><br><span class="line">PIMAGE_SECTION_HEADER pSec = (PIMAGE_SECTION_HEADER)((DWORD)pOpt + pFile-&gt;SizeOfOptionalHeader);</span><br><span class="line">PIMAGE_DATA_DIRECTORY pDir = (PIMAGE_DATA_DIRECTORY)((DWORD)pSec - <span class="built_in">sizeof</span>(DWORD) * <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">Set_IAT_HOOK</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dwNewAddress = (PDWORD)MyMessageBoxA;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 获取MessageBox的函数地址</span></span><br><span class="line">HMODULE hUser32 = <span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!hUser32)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;User32未加载\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">dwOldAddress = (PDWORD)<span class="built_in">GetProcAddress</span>(hUser32, <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取导入表地址</span></span><br><span class="line">PIMAGE_IMPORT_DESCRIPTOR pImport = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hImageBase + pDir[<span class="number">1</span>].VirtualAddress);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历每个导入表的IAT表</span></span><br><span class="line"><span class="keyword">while</span> (pImport-&gt;Name != <span class="number">0</span> &amp;&amp; flag == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">PDWORD IAT = (PDWORD)((DWORD)hImageBase + pImport-&gt;FirstThunk);</span><br><span class="line"><span class="keyword">while</span> (*IAT != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*IAT == (DWORD)dwOldAddress)</span><br><span class="line">&#123;</span><br><span class="line">DWORD OldProtected;</span><br><span class="line"><span class="built_in">VirtualProtect</span>((LPVOID)IAT, <span class="number">0x4</span>, PAGE_EXECUTE_READWRITE, &amp;OldProtected);</span><br><span class="line">*IAT = (DWORD)dwNewAddress;</span><br><span class="line"><span class="built_in">VirtualProtect</span>((LPVOID)IAT, <span class="number">0x4</span>, OldProtected, &amp;OldProtected);</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">IAT++;</span><br><span class="line">&#125;</span><br><span class="line">pImport++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">MyMessageBoxA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HWND hwnd,</span></span></span><br><span class="line"><span class="params"><span class="function">LPCSTR lpText,</span></span></span><br><span class="line"><span class="params"><span class="function">LPCSTR lpCaption,</span></span></span><br><span class="line"><span class="params"><span class="function">UINT uType</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 定义MessageBox函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(WINAPI* PFNMESSAGEBOXA)</span><span class="params">(HWND, LPCSTR, LPCSTR, UINT)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取参数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取到的函数参数：\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hwnd: %08X\tlpText: %s\nlpCaption: %s\tuType: %d\n&quot;</span>, (DWORD)hwnd, lpText, lpCaption, uType);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行真正的函数</span></span><br><span class="line"><span class="type">int</span> Ret = ((PFNMESSAGEBOXA)(PDWORD)dwOldAddress)(<span class="literal">NULL</span>, <span class="string">&quot;HOOK Success&quot;</span>, <span class="string">&quot;IAT HOOK&quot;</span>, MB_OK);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取返回值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;返回值: %d\n&quot;</span>, Ret);</span><br><span class="line"><span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消IATHOOK</span></span><br><span class="line"><span class="function">VOID <span class="title">UnIATHOOK</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取导入表地址</span></span><br><span class="line">PIMAGE_IMPORT_DESCRIPTOR pImport = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hImageBase + pDir[<span class="number">1</span>].VirtualAddress);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历每个导入表的IAT表</span></span><br><span class="line"><span class="keyword">while</span> (pImport-&gt;Name != <span class="number">0</span> &amp;&amp; flag == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">PDWORD IAT = (PDWORD)((DWORD)hImageBase + pImport-&gt;FirstThunk);</span><br><span class="line"><span class="keyword">while</span> (*IAT != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*IAT == (DWORD)dwNewAddress)</span><br><span class="line">&#123;</span><br><span class="line">DWORD OldProtected;</span><br><span class="line"><span class="built_in">VirtualProtect</span>((LPVOID)IAT, <span class="number">0x4</span>, PAGE_EXECUTE_READWRITE, &amp;OldProtected);</span><br><span class="line">*IAT = (DWORD)dwOldAddress;</span><br><span class="line"><span class="built_in">VirtualProtect</span>((LPVOID)IAT, <span class="number">0x4</span>, OldProtected, &amp;OldProtected);</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">IAT++;</span><br><span class="line">&#125;</span><br><span class="line">pImport++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Main.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>IAT_Hook.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置HOOK</span></span><br><span class="line">VOID <span class="title function_">Set_IAT_HOOK</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个自己的函数MessageBox</span></span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">MyMessageBoxA</span><span class="params">(</span></span><br><span class="line"><span class="params">HWND hwnd,</span></span><br><span class="line"><span class="params">LPCSTR lpText,</span></span><br><span class="line"><span class="params">LPCSTR lpCaption,</span></span><br><span class="line"><span class="params">UINT uType</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消IATHOOK</span></span><br><span class="line">VOID <span class="title function_">UnIATHOOK</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h6 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h6><p>当第一个MessageBox执行时就是系统原本的函数，然后我们启动HOOK<br><img src="/./../images/QQ_1728219115474.png" alt="QQ_1728219115474"></p><p>可以看见第二个窗口的显示和第二个MessageBox输入的参数不一样，命令行中输出了关于这个函数参数的信息。成功HOOK<br><img src="/./../images/QQ_1728219152077.png" alt="QQ_1728219152077"></p><p>当我们卸载掉HOOK时，函数就恢复成原来的样子了。<br><img src="/./../images/QQ_1728219185092.png" alt="QQ_1728219185092"></p><h6 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h6><ol><li>在修改IAT表中的地址时由于是对进程进行操作的，所以需要<code>VirtualProtect()</code>函数对内存权限修改才能将地址写进去。</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><hr><h6 id="1-课上的问题"><a href="#1-课上的问题" class="headerlink" title="1. 课上的问题"></a>1. 课上的问题</h6><ol><li><p>什么时候函数地址不在IAT表当中<br> 答：自己手动Load时函数地址就不在IAT表当中了，这种如果查看反汇编的话就会发现用的是直接call</p></li><li><p>定义MyMessageBox时可不可以改成这样子<br> ![[Pasted image 20241006222809.png]]<br> 答：不行，因为此时的IAT表已经被修改，用MessageBox就相当于调用了MyMessageBox，这样会造成无限递归。</p></li></ol><h6 id="2-IAT-HOOK的局限性"><a href="#2-IAT-HOOK的局限性" class="headerlink" title="2. IAT HOOK的局限性"></a>2. IAT HOOK的局限性</h6><p>有些不能HOOK，比如一些自己写的函数，或者自己手动load的函数，都不存在IAT表，所以都无法HOOK</p>]]></content>
      
      
      <categories>
          
          <category> 滴水三期 </category>
          
          <category> win32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滴水三期 </tag>
            
            <tag> win32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19.ShellCode_远程线程注入</title>
      <link href="/2024/10/07/RemoteThread-inject/"/>
      <url>/2024/10/07/RemoteThread-inject/</url>
      
        <content type="html"><![CDATA[<h1 id="远程线程注入"><a href="#远程线程注入" class="headerlink" title="远程线程注入"></a>远程线程注入</h1><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><hr><p>如果有一个程序，我们想在他里面执行我们自己的东西有什么办法呢？ </p><ul><li><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4></li></ul><p><img src="/./../images/QQ_1727865179500-1728269927669-1.png" alt="QQ_1727865179500"><br>    我们可以让程序执行到这个虚线的地方，然后让他跳到这个function()，执行完function后再跳回原来的下一条指令。这种方式执行的就叫做HOOK</p><ul><li><h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4>  我们可以直接开一个线程，这个线程就用来跑外面自己的代码。<br>  <img src="/./../images/QQ_1727867497096-1728269941937-3.png" alt="QQ_1727867497096"></li></ul><p>但是不管是哪种方法，都需要将外面自己的代码贴到进程A中才行</p><h3 id="分为模块注入和代码注入"><a href="#分为模块注入和代码注入" class="headerlink" title="分为模块注入和代码注入"></a>分为模块注入和代码注入</h3><hr><h4 id="代码注入："><a href="#代码注入：" class="headerlink" title="代码注入："></a>代码注入：</h4><pre><code> 没有全局变量和没有使用IAT表的硬编码，放在任何位置都能执行</code></pre><ul><li>优点：很难被发现</li><li>缺点：写起来很麻烦(因为有全局变量地址和IAT函数地址)</li></ul><h4 id="模块注入："><a href="#模块注入：" class="headerlink" title="模块注入："></a>模块注入：</h4><pre><code>将模块一整个注入进去，这个模块可以是dll、exe等等</code></pre><ul><li>优点：写起来非常简单</li><li>缺点：非常容易被查杀</li></ul><h3 id="自己的进程加载DLL"><a href="#自己的进程加载DLL" class="headerlink" title="自己的进程加载DLL"></a>自己的进程加载DLL</h3><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、自己的进程加载dll</span></span><br><span class="line">HINSTANCE   hModule = LoadLibrary(<span class="string">&quot;InjectDll.dll&quot;</span>);</span><br><span class="line"><span class="comment">// 2、释放dll</span></span><br><span class="line">FreeLibrary(hModule);</span><br></pre></td></tr></table></figure><h3 id="远程线程注入-1"><a href="#远程线程注入-1" class="headerlink" title="远程线程注入"></a>远程线程注入</h3><hr><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><ul><li><p>B 往A注入需要提供线程函数的地址(需要在A中)，和线程函数参数(也要在A中)<br><img src="/./../images/asda.png" alt="asda"></p></li><li><p>线程函数是有格式要求的，类型是DWORD，调用约定是WINAPI，参数是void* 的指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DWORD WINAPI <span class="title function_">Function</span><span class="params">(LPVOID lParameter)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> ExitCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>有个偶然的东西就是，在程序中加载模块时用的函数是：<code>LoadLoadLibrary</code>而这个函数是这样的 </p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMODULE <span class="title function_">LoadLibraryA</span><span class="params">( [in] LPCSTR lpLibFileName )</span>;</span><br></pre></td></tr></table></figure><p>  根据以往的学到的知识，我们可以知道这个HMODULE其实就是一个DWORD，然后参数是个LPCSTR，可以转成void* 用。</p></li><li><p>由于LoadLibrary所属模块是每个程序一定要加载的，所以他这个函数的地址都一样(关闭地址随机化)，所以我们创建线程时的线程函数直接将这个LoadLibrary的函数指针扔过去就行了</p></li><li><p>此外这个函数还需要一个函数参数，即模块名称，这时候就要从进程B，将这个模块名写道进程A中了（WriteProcessMemory）先申请空间</p></li><li><p>最后通过GetExitCodeThread获取线程的退出码，而LoadLibrary的返回值就是模块首地址，所以我们获取的就是模块句柄</p></li></ul><h3 id="所需函数"><a href="#所需函数" class="headerlink" title="所需函数"></a>所需函数</h3><hr><p>平常我们在一个进程中创建线程时用的是CreateThread:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HANDLE WINAPI <span class="title function_">CreateThread</span><span class="params">(</span></span><br><span class="line"><span class="params">LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span><br><span class="line"><span class="params">SIZE_T dwStackSize,</span></span><br><span class="line"><span class="params">LPTHREAD_START_ROUTINE lpStartAddress,</span></span><br><span class="line"><span class="params">LPVOID lpParameter,</span></span><br><span class="line"><span class="params">DWORD dwCreationFlags,</span></span><br><span class="line"><span class="params">PDWORD lpThreadId</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>而我们要在进程B中让进程A创建一个线程时用的是CreateRemoteThread：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HANDLE WINAPI <span class="title function_">CreateRemoteThread</span><span class="params">(</span></span><br><span class="line"><span class="params">HANDLE hProcess,       <span class="comment">// 不同的地方</span></span></span><br><span class="line"><span class="params">LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span><br><span class="line"><span class="params">SIZE_T dwStackSize,</span></span><br><span class="line"><span class="params">LPTHREAD_START_ROUTINE lpStartAddress,</span></span><br><span class="line"><span class="params">LPVOID lpParameter,</span></span><br><span class="line"><span class="params">DWORD dwCreationFlags,</span></span><br><span class="line"><span class="params">LPDWORD lpThreadId</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>这两个唯一的不同点就是CreateRemoteThread多了一个hProcess</p><h2 id="注入流程"><a href="#注入流程" class="headerlink" title="注入流程"></a>注入流程</h2><hr><ol><li>打开要被注入的进程</li><li>远程进程中申请空间VirtualAllocEx</li><li>向进程中写入数据(dll名)WriteProcessMemory</li><li>在远程进程中创建线程CreateRemoteThread</li><li>等待线程结束返回 WaitForSingleObject</li><li>释放空间VirtualFreeEx</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><hr><h4 id="Dll代码："><a href="#Dll代码：" class="headerlink" title="Dll代码："></a>Dll代码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">()</span> &#123;</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">&quot;注入成功，Dll初始化&quot;</span>), TEXT(<span class="string">&quot;Init&quot;</span>), MB_OK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Destory</span><span class="params">()</span> &#123;</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">&quot;程序结束，销毁&quot;</span>), TEXT(<span class="string">&quot;Destory&quot;</span>), MB_OK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL APIENTRY <span class="title function_">DllMain</span></span><br><span class="line"><span class="params">(HANDLE hModule,</span></span><br><span class="line"><span class="params">DWORD u1_reason_for_call,</span></span><br><span class="line"><span class="params">LPVOID lpReserved)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (u1_reason_for_call)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">Init();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">Destory();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的dll模块就不写那么花里胡哨了，只要能体现出来注入成功就行了：在dll初始化时弹出一个对话框，还有被销毁时弹出一个对话框。</p><h4 id="进程B代码："><a href="#进程B代码：" class="headerlink" title="进程B代码："></a>进程B代码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 获取相关PID</span></span><br><span class="line">DWORD <span class="title function_">GetPid</span><span class="params">(LPWSTR name)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 获取进程快照</span></span><br><span class="line">HANDLE hProcSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 判断是否打开成功</span></span><br><span class="line">assert(hProcSnap != INVALID_HANDLE_VALUE);</span><br><span class="line"></span><br><span class="line">PROCESSENTRY32 pe32;</span><br><span class="line">pe32.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取进程列表中的第一个进程</span></span><br><span class="line">BOOL flag = Process32First(hProcSnap, &amp;pe32);</span><br><span class="line"><span class="keyword">while</span> (flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (wcscmp(pe32.szExeFile, name) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">CloseHandle(hProcSnap);</span><br><span class="line"><span class="keyword">return</span> pe32.th32ProcessID;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取下一个进程</span></span><br><span class="line">flag = Process32Next(hProcSnap, &amp;pe32);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CloseHandle(hProcSnap);</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">&quot;没有获取到相关进程&quot;</span>), TEXT(<span class="string">&quot;错误&quot;</span>), MB_OK);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要注入的进程名称(.exe): &quot;</span>);</span><br><span class="line">TCHAR Filename[MAX_PATH] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">wscanf_s(<span class="string">L&quot;%ls&quot;</span>, Filename, MAX_PATH);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入模块名称(.exe): &quot;</span>);</span><br><span class="line">CHAR DllName[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">scanf_s(<span class="string">&quot;%s&quot;</span>, DllName, MAX_PATH);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DWORD Pid = GetPid(Filename);</span><br><span class="line">HANDLE hProcess = ::OpenProcess(PROCESS_ALL_ACCESS, FALSE, Pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在进程A中分配放置dllname的空间</span></span><br><span class="line">LPVOID Address = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, <span class="number">256</span>, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (!Address)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;进程内存空间申请失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将dll名写入进程A中</span></span><br><span class="line">DWORD DllNameAddr = WriteProcessMemory(hProcess, Address, DllName, <span class="number">256</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建远程线程</span></span><br><span class="line">HANDLE hRemoteThread = ::CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPTHREAD_START_ROUTINE)LoadLibraryA, Address, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!hRemoteThread) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;远程线程创建失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待线程结束</span></span><br><span class="line">WaitForSingleObject(hRemoteThread, INFINITE);</span><br><span class="line">DWORD ExitCode = <span class="number">0</span>;</span><br><span class="line">GetExitCodeThread(hRemoteThread, &amp;ExitCode);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;注入的dll地址是: 0x%X\n&quot;</span>, ExitCode);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先打开要注入的进程A(32位)，这里我就用之前写的Pe查看器来测试，先把他重命名一下test1.exe。不知道为什么用之前的进程名搜不出pid。打开后直接运行注入程序。<br><img src="/./../images/QQ_1727953734975.png" alt="QQ_1727953734975"><br>这里的模块(.exe)写多了，不用管。然后查看”pe查看器”<br><img src="/./../images/QQ_1727953784422.png" alt="QQ_1727953784422"><br>已经注入成功了，dll贴到4GB空间了。当我们关掉”test1.exe”时还会弹出销毁窗口，并且进程B中会输出dll注入到的地址：<br><img src="/./../images/213.png" alt="213"><br><img src="/./../images/asdaw.png" alt="asdaw"></p><h3 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h3><hr><ol><li>如何启动我们想在A进程中执行的代码？</li><li>如何卸载我们远程注入的DLL?</li></ol><h4 id="1-卸载我们远程注入的DLL"><a href="#1-卸载我们远程注入的DLL" class="headerlink" title="1. 卸载我们远程注入的DLL"></a>1. 卸载我们远程注入的DLL</h4><p>用FreeLibrary为线程函数，远程卸载就行了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hRemoteThread = ::CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPTHREAD_START_ROUTINE)FreeLibrary, (LPVOID)ExitCode, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!hRemoteThread)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;卸载dll远程线程创建失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">WaitForSingleObject(hRemoteThread, INFINITE);</span><br><span class="line">GetExitCodeThread(hRemoteThread, &amp;ExitCode);</span><br></pre></td></tr></table></figure><h4 id="2-如何启动我们想在A进程中执行的代码？"><a href="#2-如何启动我们想在A进程中执行的代码？" class="headerlink" title="2. 如何启动我们想在A进程中执行的代码？"></a>2. 如何启动我们想在A进程中执行的代码？</h4><p>答： 需要用到进程通信</p>]]></content>
      
      
      <categories>
          
          <category> 滴水三期 </category>
          
          <category> win32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滴水三期 </tag>
            
            <tag> win32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18.OD+CE练习</title>
      <link href="/2024/10/02/OD-CE/"/>
      <url>/2024/10/02/OD-CE/</url>
      
        <content type="html"><![CDATA[<h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><hr><p>将上节课的第八关：多级指针用OD找出。</p><p>首先用OD打开测试题，运行到第八关这里我用x64dbg。</p><p><img src="/./../images/QQ_1727849210680.png" alt="QQ_1727849210680"></p><p>OK，已经是第八关了，然后我们再用CE找出改变这个数值的指令在什么位置。将信息复制出来，然后在xdbg里直接跳到这个位置。(这里是没有做地址随机才可以这样)</p><p><img src="/./../images/QQ_1727849388747.png" alt="QQ_1727849388747"></p><p>我们来到xdbg看看是怎么情况：</p><p><img src="/./../images/QQ_1727849538243.png" alt="QQ_1727849538243"></p><p>跳到这个位置，发现就是将eax,移动到[rsi + 0x18]地址。在这里打上断点see see，然后在第八关点击改变数值，程序就会断在这里</p><p><img src="/./../images/QQ_1727849687658.png" alt="QQ_1727849687658"></p><p>到这里后看看rsi的值：</p><p><img src="/./../images/QQ_1727849824238.png" alt="QQ_1727849824238"></p><p>这个rsi已经是最终值了，我们看看这个[rsi+0x18]里面装了啥东西。在下面的命令窗口中输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dump rsi+<span class="number">0x18</span></span><br></pre></td></tr></table></figure><p>在od中的指令是：<code>dd rsi + 0x18</code></p><p><img src="/./../images/QQ_1727849908321.png" alt="QQ_1727849908321"></p><p>这样内存窗口就到了地址<code>rsi+0x18</code>的位置了。然后这个四字节应该就是数值了，但是现在还不是更改后的。我们将程序放过去，然后在查看这个位置的值。</p><p><img src="/./../images/QQ_1727850041316.png" alt="QQ_1727850041316"></p><p>可以看到现在这里存着的是2315，看看关卡中的值是什么：</p><p><img src="/./../images/QQ_1727850093433.png" alt="QQ_1727850093433"></p><p>那么这个地址就对了。再看看上面xdbg的指令，是将eax的值放到[rsi+0x18]中,先将第一次层地址关系写出来，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">值 = [rsi+<span class="number">0x18</span>]</span><br></pre></td></tr></table></figure><p>然后我们下一步就要找rsi的值是怎么来的，我们往上找，先找最近的第一个rsi(放在左边的rsi):</p><p><img src="/./../images/QQ_1727850782071.png" alt="QQ_1727850782071"></p><p>找到最近的一个rsi，现在这个地方断个点，然后改变数值执行一下，看看会不会执行这段代码，如果不会就继续往上找(后面的也是这样处理)。这里运行了一下，发现确实能够被断下，那这里就是第层了，此时rsi的值是被<code>mov rsi,[rsi]</code>改的所以这里的地址关系式就是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">值 = [[rsi] + <span class="number">0x18</span>]</span><br></pre></td></tr></table></figure><p>OK,那下一步就是找右边的rsi是怎么改变的了，继续往上找：</p><p><img src="/./../images/QQ_1727851056580.png" alt="QQ_1727851056580"></p><p>还是同样的套路找出这里，到这里的关系式继续写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">值 = [[[rsi + <span class="number">0x18</span>]]+<span class="number">0x18</span>]</span><br></pre></td></tr></table></figure><p>继续重复，下一层还是找rsi改变的地方：</p><p><img src="/./../images/QQ_1727851173864.png" alt="QQ_1727851173864"></p><p>写出这里的关系：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">值 = [[[[rsi+<span class="number">0x10</span>]+<span class="number">0x18</span>]]+<span class="number">0x18</span>]</span><br></pre></td></tr></table></figure><p>继续下一层，找rsi：</p><p><img src="/./../images/QQ_1727851269061.png" alt="QQ_1727851269061"></p><p>OK，这里的rsi就是[100325B00]里面的值，每次点击改变指针，这里面的值会变，然后rsi跟着变导致之前的地址变化，我们直接用这个地址加上偏移就能直接找到存值的地址了，不管这个地址怎么变,关系式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">值 = [[[[[<span class="number">100325B</span>00]+<span class="number">0x10</span>]+<span class="number">0x18</span>]]+<span class="number">0x18</span>]</span><br></pre></td></tr></table></figure><p>我们将这个关系式子在命令中用<code>dump</code>查看一下：</p><p><img src="/./../images/QQ_1727851628356.png" alt="QQ_1727851628356"></p><p>可以发现这里就是那个地址了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr><ul><li>这个程序相对还是很简单的，如果遇到复杂的，在整个空间相关寄存器都没有变化的话就得看看是不是有在函数调用时，将这个值通过参数传递传进来了</li><li>还要多调试</li></ul>]]></content>
      
      
      <categories>
          
          <category> 滴水三期 </category>
          
          <category> win32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滴水三期 </tag>
            
            <tag> win32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17.CE练习</title>
      <link href="/2024/09/28/Cheat-Engine/"/>
      <url>/2024/09/28/Cheat-Engine/</url>
      
        <content type="html"><![CDATA[<h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><hr><hr><p>将完成CE自带小练习1~8<br>这篇写的有点乱了qwq</p><h2 id="第一关："><a href="#第一关：" class="headerlink" title="第一关："></a>第一关：</h2><hr><h3 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h3><ul><li>精确扫描</li><li>通过数值变化确定地址<br><img src="/./../images/QQ_1727361720535.png" alt="QQ_1727361720535"></li></ul><p>任务就是将这个100改成1000，我们可以通过CE打开这个小练习，然后扫描类型选中精确数值，数值类型从4字节开始(这个值有可能是char short int等等)我们从可能性大的DWORD 开始找，然后点击首次扫描就行了。</p><p><img src="/./../images/QQ_1727361872771.png" alt="QQ_1727361872771"><br>扫描后这里出现很多100啊，我们应该怎么找到那个100的值呢。这就是CE的精髓了，需要通过寻找变化来获取到那个地址。就例如这里的打我会让数值降低到97，那我们在精确数值那里输入97再次扫描就能看到排除了很多选项了<br><img src="/./../images/QQ_1727362028546.png" alt="QQ_1727362028546"></p><p>这个地址的97应该就是我们需要的了，直接双击一下，然后在数值那里改成1000，就可以下一步了：<br><img src="/./../images/QQ_1727425526637.png" alt="QQ_1727425526637"></p><h2 id="第二关："><a href="#第二关：" class="headerlink" title="第二关："></a>第二关：</h2><hr><h3 id="知识点：-1"><a href="#知识点：-1" class="headerlink" title="知识点："></a>知识点：</h3><ul><li>介于两者之间的扫描类型</li><li>通过变化扫描</li></ul><p><img src="/./../images/222.png" alt="222"></p><p>OK，那我们这次就可以在新的扫描前选择介于两者之间<br><img src="/./../images/QQ_1727425818197.png" alt="QQ_1727425818197"></p><p>然后回到CE的精髓就是变化，点击”打我”让这个地址的数值发生变化，然后在扫描类型中选择数值变化的方向（增加还是减少）这里”打我”了两次,第二次是-9，那就是数值减少了9，然后再进行再次扫描就扫出来了，然后直接把这个值改成题目要求的就能过了。<br><img src="/./../images/QQ_1727426148994.png" alt="QQ_1727426148994"></p><h2 id="第三关"><a href="#第三关" class="headerlink" title="第三关"></a>第三关</h2><hr><h3 id="知识点：-2"><a href="#知识点：-2" class="headerlink" title="知识点："></a>知识点：</h3><ul><li>单精度，双精度浮点扫描</li></ul><p>在前面的教程中我们使用字节的方式进行扫描，但有些游戏使用了”浮点数”来存储数值（这么做是为了给菜鸟制造一些麻烦，让他们没那么容易修改游戏）。<br>正如本关中的健康和弹药，两者都以浮点方法储存数据，不同的是，健康值为单精度浮点数，而弹药值为双精度浮点数。<br>点击”打我”将减少一些健康值，而点击”开火”则消耗掉 0.5 的弹药。<br><img src="/./../images/QQ_1727426391155.png" alt="QQ_1727426391155"></p><p>这个的话就按照上面的方法然后将数值类型换成单浮点和双浮点一个个找就行了。</p><h2 id="第四关"><a href="#第四关" class="headerlink" title="第四关"></a>第四关</h2><hr><h3 id="知识点：-3"><a href="#知识点：-3" class="headerlink" title="知识点："></a>知识点：</h3><ul><li>找出什么改写了这个地址的使用</li><li>修改汇编代码</li></ul><blockquote><p>这关的要求就是：点击改变数值时不让这个数值发生变化<br><img src="/./../images/QQ_1727504922208.png" alt="QQ_1727504922208"></p></blockquote><p>我们可以先通过精确查找找出这个值存放的位置，(观察bianhua!!)，接着可以右键查看是什么改写了该地址。就是看看什么指令对这个地址操作了，然后查看汇编窗口直接修改指令就好了。<br>![Pasted image 20240928143348](.&#x2F;..&#x2F;images&#x2F;Pasted image 20240928143348.png)</p><p>右键选框，然后再选择找出是什么改写了这个地址，接着就会打开弹出这个页面，选择改变数值后右边的窗口就会出现让这个地址里面的值改变的代码，这时候选中这条指令，显示反汇编程序，就可以将这个指令进行修改了，要想数值不变，直接将这个指令改成nop就行。</p><p><img src="/./../images/4353.png" alt="4353"></p><blockquote><p>可以看到当我们点击改变数值的时候这个值也不会变化了，下一步按钮也亮了</p></blockquote><p><img src="/./../images/QQ_1727505504581.png" alt="QQ_1727505504581"></p><h2 id="第五关"><a href="#第五关" class="headerlink" title="第五关"></a>第五关</h2><hr><h3 id="知识点：-4"><a href="#知识点：-4" class="headerlink" title="知识点："></a>知识点：</h3><ul><li>指针</li><li>通过添加地址来设置指针</li></ul><p>上一关使用了代码查找器，这一关则使用指针的方法确定地址。<br>点击 <code>改变数值</code> 数值都会改变。点击 <code>改变指针</code> 有点类似重新开始一局游戏，这意味着，数值的地址会改变。<br>你需要做的是：将数值锁定在5000，即使点击 <code>改变指针</code> 改变了数值所在地址之后。</p><p><img src="/./../images/QQ_1727505958080.png" alt="QQ_1727505958080"></p><p>首先先通过前面的步骤先找到这个数值所在的地址。然后通过 “找出是什么改写了该地址” 找出这个值变化的指令：</p><p><img src="/./../images/QQ_1727506212450.png" alt="QQ_1727506212450"></p><p>OK，那么这个就是改变数值的指令。不难发现这个<code>[rdx]</code>就是个指针，然后选中这条指令，详细信息，就可以看到rdx的值。</p><p><img src="/./../images/QQ_1727506550510.png" alt="QQ_1727506550510"></p><p>此时的rdx是这个值，我们直接选择新的扫描，然后把十六进制勾上<br>![Pasted image 20240928145941](.&#x2F;..&#x2F;images&#x2F;Pasted image 20240928145941.png)<br>这里出现了两个，直觉告诉我是第二个才是。在大一点的程序中分析时搜一个值可能会出现多个情况，这下就要逐一排查了。这里我选择第二个。然后这里存储的就是那个地址了嘛，右键然后更改记录，选择地址<br>![Pasted image 20240928150632](.&#x2F;..&#x2F;images&#x2F;Pasted image 20240928150632.png)</p><p>然后勾选指针，可以看出这个就是存着 存着数值的那个地址 的地址了。然后点击确定<br><img src="/./../images/QQ_1727507238664-1727519482207-18.png" alt="QQ_1727507238664"></p><p>这里改成5000，然后激活勾选上(里面的值锁定)，点击改变指针就发现5000被锁定了。OK下一关</p><h2 id="第六关：代码注入"><a href="#第六关：代码注入" class="headerlink" title="第六关：代码注入"></a>第六关：代码注入</h2><hr><h3 id="知识点：-5"><a href="#知识点：-5" class="headerlink" title="知识点："></a>知识点：</h3><ul><li>当要修改一段指令的时长度不够怎么办</li></ul><blockquote><p>任务要求：点击改变数值时将数值增加</p></blockquote><p><img src="/./../images/QQ_1727510500094.png" alt="QQ_1727510500094"></p><p>老样子，重复第四关的操作，知道打开正确的汇编代码页面，然后选中修改值的那条指令-&gt;工具-&gt;自动汇编<br><img src="/./../images/4353-1727520177159-8.png" alt="4353"></p><p>然后就会弹出这个框，选择模板，代码注入然后就会自动生成一个模板，在这里修改成<code>add dword ptr [rsi+000007E0],02</code>就行<br>![Pasted image 20240928160610](.&#x2F;..&#x2F;images&#x2F;Pasted image 20240928160610.png)<br><img src="/./../images/QQ_1727510827476.png" alt="QQ_1727510827476"></p><p>点击执行，再回到教程中点击改变数值就已经是增加了。</p><h6 id="注入原理："><a href="#注入原理：" class="headerlink" title="注入原理："></a>注入原理：</h6><ul><li>这里的代码注入原理其实与之前课程里面讲到的在空白区域加代码很像，只不过那个是在静态文件中加的，这个是在程序运行后加的</li></ul><h2 id="第七关：多级指针"><a href="#第七关：多级指针" class="headerlink" title="第七关：多级指针"></a>第七关：多级指针</h2><hr><h3 id="知识点：-6"><a href="#知识点：-6" class="headerlink" title="知识点："></a>知识点：</h3><ul><li>对指针和多级指针的汇编熟练度</li></ul><blockquote><p>任务要求：还是设置值，然后在改变指针时锁定这个值</p></blockquote><p><img src="/./../images/sadasd.png" alt="sadasd"></p><p>还是老样子，先找出这个值所在的地址，然后找出是什么改变了这个地址<br><img src="/./../images/sadasd-1727520228447-13.png" alt="sadasd"><br>发现是这么个东西，这个样子就像是结构体。（不知道也不影响)然后我们记下这个指令和此时rsi的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov [rsi + <span class="number">0x18</span>] , eax</span><br><span class="line"><span class="meta"># rsi = 000000000163E170</span></span><br></pre></td></tr></table></figure><p>那我们就开始往上找了。将这个rsi的值复制出来，然后新的扫描-&gt;十六进制-&gt;首次扫描，接着就找到了存这个rsi的地址了。<br><img src="/./../images/sadasd-1727520214646-11.png" alt="sadasd"></p><p>下一步我们右键这个选项，然后选择找出是谁访问了该地址。这里为什么不用改写呢？因为访问包括了改写，但是如果对这里的操作不一定是改写，也有可能是引用。（就是从里面拿值）<br><img src="/./../images/QQ_1727512609729.png" alt="QQ_1727512609729"></p><p>接下来找到有两条指令，第一条cmp就不管了没啥影响。直接看第二条，就是将rsi中的值当作地址然后取这个地址里面的值给到rsi，那么我们就来看看这个rsi是什么成分。<br>诶？不对啊，为什么这个rsi和外面选中的数值是一样的？这里就是CE的一个坑了，当我们选中这段指令的时候，下面各个寄存器的信息都是这条指令执行完之后的状态，也就是说这个rsi是mov完之后的值。那我们怎么找到之前的rsi呢？这里用两种方法：</p><ol><li>断点调试：在汇编代码中这条指令的前一条指令下段，然后运行到那个位置，就能找到rsi的值了</li><li>想一想：我们当时找的不是谁访问了这个地方吗，当我们切换数值时这个<code>mov rsi,[rsi]</code>访问了这个地址，然后把这个地址，然后把rsi变成了163e170,那原来rsi是什么呢？不就是存着163e170的地址160b750了吗。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov rsi,[rsi]</span><br><span class="line"><span class="meta">#rsi = 160b750</span></span><br></pre></td></tr></table></figure>接下来就按照上面的方法查找rsi所存的地址的值<img src="/./../images/QQ_1727517193318.png" alt="QQ_1727517193318"></li></ol><p>记录下这次的指令和rsi的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov rsi,[rsi+<span class="number">0x18</span>]</span><br><span class="line"><span class="meta"># rsi+18 = 0x1624198</span></span><br></pre></td></tr></table></figure><p>这次就不能直接找这个地址的值了，因为这里的指令时<code>mov rsi,[rsi+0x18]</code>是加上0x18的，所以找的时候得将地址减去0x18即0x1624180</p><p><img src="/./../images/QQ_1727517686661.png" alt="QQ_1727517686661"></p><p>重复操作，记下这个指令和rsi</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov rsi,[rsi+<span class="number">0x10</span>]</span><br><span class="line"><span class="meta"># rsi+0x10 = 15a1080</span></span><br><span class="line"><span class="meta"># rsi = 15a1070</span></span><br></pre></td></tr></table></figure><p>接着继续搜15a1070<br><img src="/./../images/QQ_1727518063105.png" alt="QQ_1727518063105"></p><p>这里已经看见基址了，就说明找指针这个过程完成了,根据上述记录的各个操作我们可以得出以下式子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># [rsi+<span class="number">0x18</span>] = [[rsi]+<span class="number">0x18</span>] = [[[rsi+<span class="number">0x18</span>]]+<span class="number">0x18</span>] = [[[[rsi + <span class="number">0x10</span>]+<span class="number">0x18</span>]]+<span class="number">0x18</span>]</span><br></pre></td></tr></table></figure><p>这里的rsi指的是不同级的<br>所以最终的数值存放的位置用指针来表示就是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># [[[[基址 + <span class="number">0x10</span>]+<span class="number">0x18</span>]]+<span class="number">0x18</span>]</span><br></pre></td></tr></table></figure><p>我们在选中最下面的那个选项然后按照之前设置指针的方法将它设置成指针，但是要添加偏移量<br>![Pasted image 20240928181435](.&#x2F;..&#x2F;images&#x2F;Pasted image 20240928181435.png)<br>点击确定后可以看到已经指向了数值位置了<br>![Pasted image 20240928181810](.&#x2F;..&#x2F;images&#x2F;Pasted image 20240928181810.png)<br>我们将值改成5000然后锁定，改变指针然后就可以过关了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr><p>这只是CE的一个附带小程序，所以查找会比较方便。但是一些大一点的程序可能每次扫描出来的结果会有很多，这时候就得慢慢查找了。还得不断练习提升。</p>]]></content>
      
      
      <categories>
          
          <category> 滴水三期 </category>
          
          <category> win32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滴水三期 </tag>
            
            <tag> win32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14.win32进程创建_句柄表</title>
      <link href="/2024/09/16/win32-create-process/"/>
      <url>/2024/09/16/win32-create-process/</url>
      
        <content type="html"><![CDATA[<h1 id="win32-进程创建-句柄表"><a href="#win32-进程创建-句柄表" class="headerlink" title="win32 进程创建_句柄表"></a>win32 进程创建_句柄表</h1><hr><p>在之前的学习中，我们了解到了，程序、镜像(ImageBuffer)、进程。那么这三个有什么区别呢？</p><blockquote><p>通俗来讲程序就是写好的.exe但是还没有运行，死的一个东西；镜像是将程序按照PE格式拉伸贴到4GB空间中的东西，而进程就是这个镜像跑起来后的东西。当eip”给到”这个ImageBufffer时这个就运行起来了</p></blockquote><p>父进程创建子进程，父进程挂了子进程不会挂</p><h2 id="一、进程创建的过程"><a href="#一、进程创建的过程" class="headerlink" title="一、进程创建的过程"></a>一、进程创建的过程</h2><hr><p><img src="/./../images/image-20240916164833028.png" alt="image-20240916164833028"></p><h3 id="步骤一："><a href="#步骤一：" class="headerlink" title="步骤一："></a>步骤一：</h3><p>当系统启动后，会创建一个进程：Explorer.exe 也就是桌面进程。</p><h3 id="步骤二："><a href="#步骤二：" class="headerlink" title="步骤二："></a>步骤二：</h3><p>当用户双击某一个exe时，Explorer 进程使用CreateProcess函数创建被双击的exe，也就是说：我们在桌面上双击创建的进程都是Explorer进程的子进程。</p><p>我们可以通过XueTr.exe ，查看那些进程是由Explorer创建的。</p><p><img src="/./../images/image-20240916173018779.png" alt="image-20240916173018779"></p><h2 id="二、CreateProcess函数做了什么"><a href="#二、CreateProcess函数做了什么" class="headerlink" title="二、CreateProcess函数做了什么"></a>二、CreateProcess函数做了什么</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CreateProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">    LPCTSTR lpApplicationName,                 <span class="comment">// name of executable module</span></span></span><br><span class="line"><span class="params">    LPTSTR lpCommandLine,                      <span class="comment">// command line string</span></span></span><br><span class="line"><span class="params">    LPSECURITY_ATTRIBUTES lpProcessAttributes, <span class="comment">// SD</span></span></span><br><span class="line"><span class="params">    LPSECURITY_ATTRIBUTES lpThreadAttributes,  <span class="comment">// SD</span></span></span><br><span class="line"><span class="params">    BOOL bInheritHandles,                      <span class="comment">// handle inheritance option</span></span></span><br><span class="line"><span class="params">    DWORD dwCreationFlags,                     <span class="comment">// creation flags</span></span></span><br><span class="line"><span class="params">    LPVOID lpEnvironment,                      <span class="comment">// new environment block</span></span></span><br><span class="line"><span class="params">    LPCTSTR lpCurrentDirectory,                <span class="comment">// current directory name</span></span></span><br><span class="line"><span class="params">    LPSTARTUPINFO lpStartupInfo,               <span class="comment">// startup information</span></span></span><br><span class="line"><span class="params">    LPPROCESS_INFORMATION lpProcessInformation <span class="comment">// process information</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><p>现在先主要了解几个，其他的等用到再了解：</p><ol><li><code>lpApplicationName</code> : 要执行的程序的名称，字符串可以指定要执行的模块的完整路径和文件名，也可以指定部分名称。如果只有程序名称没有路径，则系统会按照以下顺序解释：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c:\program.exe</span><br><span class="line">c：\program files\sub.exe</span><br><span class="line">c：\program files\sub dir\program.exe</span><br><span class="line">c：\program files\sub dir\program name.exe</span><br></pre></td></tr></table></figure><ol start="2"><li><p><code>[in, out, optional] lpCommandLine</code> : 要执行的命令行</p></li><li><p><code>[in] bInheritHandles</code> : 如果这个参数为TRUE，句柄表可继承的句柄都会被由这个进程创建的进程继承。如：A进程句柄表中的存在0x1句柄，并且这个句柄可以被继承，如果A进程通过CreateProcess创建出进程B则进程B，就能继承这个0x1</p></li><li><p><code>[in] lpStartupInfo</code> : 指向<a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/processthreadsapi/ns-processthreadsapi-startupinfoa">STARTUPINFO</a>或<a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/ns-winbase-startupinfoexa">STARTUPINFOEX</a>结构的指针，当不使用时，必须用CloseHandle关闭他们。</p></li><li><p><code>[out] lpProcessInformation</code> : 指向接收有关新进程的标识信息的 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/processthreadsapi/ns-processthreadsapi-process_information">PROCESS_INFORMATION</a> 结构的指针。</p></li></ol><h3 id="1、创建内核对象"><a href="#1、创建内核对象" class="headerlink" title="1、创建内核对象"></a>1、创建内核对象</h3><p><img src="/./../images/image-20240916173423991.png" alt="image-20240916173423991"></p><p>当CreateProcess后，就会创建这个句柄表，但是这个表刚刚创建的时候是空的。得做Create内核对象时计数器++，然后往表里面写东西。</p><p><strong>句柄表</strong>：第一列就是句柄，也就是我们常用的hThread之类的，相当与是内核对象的编号；第二列是内核对象的真正地址，第三列表示能不能被继承</p><h3 id="2、分配4GB的虚拟内存空间-Windows-32位"><a href="#2、分配4GB的虚拟内存空间-Windows-32位" class="headerlink" title="2、分配4GB的虚拟内存空间(Windows 32位)"></a>2、分配4GB的虚拟内存空间(Windows 32位)</h3><p><img src="/./../images/image-20240916173854180.png" alt="image-20240916173854180"></p><p>创建线程的过程：</p><ol><li>将exe拉伸，存储到指定位置</li><li>遍历exe导入表，将需要用到的dll拉伸存储到指定位置，如果位置被占用，换地方，并通过DLL的重定位表，修复全局</li><li>DLL如果引用了其他DLL，递归第二步</li><li>修复exe&#x2F;dll中的IAT表</li><li>创建线程、设置线程CONTEXT开始执行</li></ol><h3 id="3、创建进程的主线程"><a href="#3、创建进程的主线程" class="headerlink" title="3、创建进程的主线程"></a>3、创建进程的主线程</h3><p><img src="/./../images/image-20240916174230289.png" alt="image-20240916174230289"></p><h2 id="三、创建进程-示例代码"><a href="#三、创建进程-示例代码" class="headerlink" title="三、创建进程(示例代码)"></a>三、创建进程(示例代码)</h2><hr><h4 id="代码一："><a href="#代码一：" class="headerlink" title="代码一："></a>代码一：</h4><p>通过名字创建，也就是CreateProcess第一个参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">TestCreateProcessByAPPName</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">STARTUPINFO si = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    PROCESS_INFORMATION pi;</span><br><span class="line"></span><br><span class="line">si.cb = <span class="keyword">sizeof</span>(si);</span><br><span class="line"></span><br><span class="line">TCHAR szApplicationName[] =TEXT(文件路径);<span class="comment">// 这里是程序的绝对地址</span></span><br><span class="line"></span><br><span class="line">BOOL res = CreateProcess(</span><br><span class="line">szApplicationName, </span><br><span class="line"><span class="literal">NULL</span>, </span><br><span class="line"><span class="literal">NULL</span>, </span><br><span class="line"><span class="literal">NULL</span>, </span><br><span class="line">FALSE, </span><br><span class="line">CREATE_NEW_CONSOLE, </span><br><span class="line"><span class="literal">NULL</span>, </span><br><span class="line"><span class="literal">NULL</span>, &amp;si, &amp;pi); </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./../images/image-20240916175237084.png" alt="image-20240916175237084"></p><p>执行后直接打开了pe查看器</p><h4 id="代码二："><a href="#代码二：" class="headerlink" title="代码二："></a>代码二：</h4><p>通过命令行打开（参数二）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">TestCreateProcessByCmdline</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">STARTUPINFO si = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    PROCESS_INFORMATION pi;</span><br><span class="line"></span><br><span class="line">si.cb = <span class="keyword">sizeof</span>(si);</span><br><span class="line"></span><br><span class="line">TCHAR szCmdline[] =TEXT(<span class="string">&quot;c://program files//internet explorer//iexplore.exe http://www.ifeng.com&quot;</span>);<span class="comment">// 程序路径 如果是浏览器还可以空格后面加网址</span></span><br><span class="line"></span><br><span class="line">BOOL res = CreateProcess(</span><br><span class="line"><span class="literal">NULL</span>, </span><br><span class="line">szCmdline, </span><br><span class="line"><span class="literal">NULL</span>, </span><br><span class="line"><span class="literal">NULL</span>, </span><br><span class="line">FALSE, </span><br><span class="line">CREATE_NEW_CONSOLE, </span><br><span class="line"><span class="literal">NULL</span>, </span><br><span class="line"><span class="literal">NULL</span>, &amp;si, &amp;pi); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="代码三："><a href="#代码三：" class="headerlink" title="代码三："></a>代码三：</h4><p>两个参数一起：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">TestCreateProcess</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">STARTUPINFO si = &#123;<span class="number">0</span>&#125;;   </span><br><span class="line">    PROCESS_INFORMATION pi;</span><br><span class="line"></span><br><span class="line">si.cb = <span class="keyword">sizeof</span>(si);</span><br><span class="line"></span><br><span class="line">TCHAR szCmdline[] =TEXT(<span class="string">&quot; http://www.ifeng.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">BOOL res = CreateProcess(</span><br><span class="line">TEXT(<span class="string">&quot;c://program files//internet explorer//iexplore.exe&quot;</span>), </span><br><span class="line">szCmdline, </span><br><span class="line"><span class="literal">NULL</span>, </span><br><span class="line"><span class="literal">NULL</span>, </span><br><span class="line">FALSE, </span><br><span class="line">CREATE_NEW_CONSOLE, </span><br><span class="line"><span class="literal">NULL</span>, </span><br><span class="line"><span class="literal">NULL</span>, &amp;si, &amp;pi); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看看最后两个结构体是什么东西：</p><h5 id="STARTUPINFO："><a href="#STARTUPINFO：" class="headerlink" title="STARTUPINFO："></a>STARTUPINFO：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STARTUPINFO</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   DWORD cb;</span><br><span class="line">   PSTR lpReserved;</span><br><span class="line">   PSTR lpDesktop;</span><br><span class="line">   PSTR lpTitle;</span><br><span class="line">   DWORD dwX;</span><br><span class="line">   DWORD dwY;</span><br><span class="line">   DWORD dwXSize;</span><br><span class="line">   DWORD dwYSize;</span><br><span class="line">   DWORD dwXCountChars;</span><br><span class="line">   DWORD dwYCountChars;</span><br><span class="line">   DWORD dwFillAttribute;</span><br><span class="line">   DWORD dwFlags;</span><br><span class="line">   WORD wShowWindow;</span><br><span class="line">   WORD cbReserved2;</span><br><span class="line">   PBYTE lpReserved2;</span><br><span class="line">   HANDLE hStdInput;</span><br><span class="line">   HANDLE hStdOutput;</span><br><span class="line">   HANDLE hStdError;</span><br><span class="line">&#125; STARTUPINFO, *LPSTARTUPINFO;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个结构体是用来设定要创建的应用程序的属性，比如可以指定新创建的控制台程序的标题等待。<strong>一般情况下</strong> 只用给第一个成员赋值就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">si.cb = <span class="keyword">sizeof</span>(si);</span><br></pre></td></tr></table></figure><h5 id="PROCESS-INFORMATION"><a href="#PROCESS-INFORMATION" class="headerlink" title="PROCESS_INFORMATION:"></a>PROCESS_INFORMATION:</h5><p>也就是最后一个参数的结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PROCESS_INFORMATION</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   HANDLE hProcess;<span class="comment">//进程句柄</span></span><br><span class="line">   HANDLE hThread;<span class="comment">//主线程句柄</span></span><br><span class="line">   DWORD dwProcessId;<span class="comment">//进程ID</span></span><br><span class="line">   DWORD dwThreadId;<span class="comment">//线程ID</span></span><br><span class="line">&#125; PROCESS_INFORMATION;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在CreateProcess函数参数说明中，这个参数前面有一个[out]的东西，说明这个是CreateProcess函数输出的详细。这个结构是用来存放 进程和主线程的句柄和ID的，我们可以用以下代码来查看:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;dwProcessId: %x dwThreadId: %x\nhProcess: %x hThread: %x\n&quot;</span>, pi.dwProcessId, pi.dwThreadId, pi.hProcess, pi.hThread);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="/./../images/image-20240916180342294.png" alt="image-20240916180342294"></p><h4 id="关于句柄和ID"><a href="#关于句柄和ID" class="headerlink" title="关于句柄和ID"></a>关于句柄和ID</h4><ol><li>都是系统分配的一个编号，句柄是客户程序使用，ID主要是系统调度时使用</li><li>调用CloseHandle关闭进程或者线程句柄的时候，只是让内核计数器减少一，并不是终止进程或者线程。<strong>进程猴子线程将继续运行，直到它自己终止运行</strong></li><li>在进程执行过程中，进程Id与线程id 是不可能相同的。但是不要通过进程或者线程ID来操作进程或者线程，因为当进程关闭或意外中断再打开后id就不是原来的ID了，因为系统会把这个ID给了其他进程或者线程</li></ol><h2 id="四、进程终止"><a href="#四、进程终止" class="headerlink" title="四、进程终止"></a>四、进程终止</h2><hr><h4 id="进程终止的三种方式："><a href="#进程终止的三种方式：" class="headerlink" title="进程终止的三种方式："></a>进程终止的三种方式：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">ExitProcess</span><span class="params">(UINT fuExitCode)</span><span class="comment">// 进程会自己调用</span></span><br><span class="line">BOOL <span class="title function_">TerminateProcess</span><span class="params">(HANDLE hProcess, UINT fuExitCode)</span>;<span class="comment">// 终止其他进程</span></span><br><span class="line">ExitThread<span class="comment">// 终止所有线程，系统就会把进程杀掉</span></span><br></pre></td></tr></table></figure><h4 id="获取进程的退出码："><a href="#获取进程的退出码：" class="headerlink" title="获取进程的退出码："></a>获取进程的退出码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">GetExitCodeProcess</span><span class="params">(HANDLE hProcess, PDWORD pdwExitCode)</span>;</span><br></pre></td></tr></table></figure><h4 id="进程终止时相关操作："><a href="#进程终止时相关操作：" class="headerlink" title="进程终止时相关操作："></a>进程终止时相关操作：</h4><ol><li>进程中剩余的所有线程全部停止运行</li><li>进程指定的所有用户对象均被释放，所有内核对象均被关闭</li><li>进程内核对象的状态变成收到通知的状态</li><li>进程内核对象的使用计数递减1</li></ol><h2 id="五、句柄的继承"><a href="#五、句柄的继承" class="headerlink" title="五、句柄的继承"></a>五、句柄的继承</h2><hr><p><strong>让不同进程间拥有相同的内核对象</strong></p><p>首先先了解一下需要用到的知识</p><h4 id="1、命令行参数的使用"><a href="#1、命令行参数的使用" class="headerlink" title="1、命令行参数的使用"></a>1、命令行参数的使用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> szBuffer[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">memcpy</span>(szBuffer,argv[<span class="number">1</span>],<span class="number">8</span>);</span><br><span class="line">DWORD dwHandle = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">sscanf</span>(szBuffer,<span class="string">&quot;%x&quot;</span>,&amp;dwHandle);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,dwHandle);</span><br><span class="line">getchar();</span><br></pre></td></tr></table></figure><h4 id="2、-句柄的继承"><a href="#2、-句柄的继承" class="headerlink" title="2、 句柄的继承"></a>2、 句柄的继承</h4><blockquote><p>我们可以通过创建一个事件内核对象来验证这个句柄的继承：</p></blockquote><h4 id="进程A中的代码："><a href="#进程A中的代码：" class="headerlink" title="进程A中的代码："></a>进程A中的代码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">TestExtendHandle</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">CHAR szBuffer[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">memset</span>(szBuffer, <span class="number">0</span>, <span class="number">256</span>);</span><br><span class="line">CHAR szHandle[<span class="number">8</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若要成功创建能继承的句柄，父进程必须指定一个SECURITY_ATTRIBUTES并对它进行初始化</span></span><br><span class="line"><span class="comment">// 三个成员的意义：大小、默认安全属性、是否可以继承</span></span><br><span class="line">SECURITY_ATTRIBUTES sa;</span><br><span class="line">sa.nLength = <span class="keyword">sizeof</span>(sa);</span><br><span class="line">sa.lpSecurityDescriptor = <span class="literal">NULL</span>;</span><br><span class="line">sa.bInheritHandle = TRUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个可以被继承的内核对象</span></span><br><span class="line">HANDLE g_hEvent = CreateEvent(&amp;sa, TRUE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组织命令行参数</span></span><br><span class="line">sprintf_s(szHandle, <span class="number">8</span>, <span class="string">&quot;%d&quot;</span>, g_hEvent);</span><br><span class="line">sprintf_s(szBuffer, <span class="number">256</span>, <span class="string">&quot;C:\\Users\\lys05\\Desktop\\test3.exe %s&quot;</span>, szHandle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义创建进程需要用到的结构体</span></span><br><span class="line">STARTUPINFOA si = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">si.cb = <span class="keyword">sizeof</span>(si);</span><br><span class="line"></span><br><span class="line">PROCESS_INFORMATION pi;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子进程</span></span><br><span class="line">BOOL ret = CreateProcessA(</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">szBuffer,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">TRUE,</span><br><span class="line">CREATE_NEW_CONSOLE,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">&amp;si, &amp;pi</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置事件为已通知</span></span><br><span class="line">SetEvent(g_hEvent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭句柄 内核对象是否会被销毁？</span></span><br><span class="line">CloseHandle(g_hEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进程B中的代码："><a href="#进程B中的代码：" class="headerlink" title="进程B中的代码："></a>进程B中的代码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">CHAR szBuffer[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">memcpy</span>(szBuffer, argv[<span class="number">1</span>],<span class="number">8</span>);</span><br><span class="line">DWORD dwHandle = <span class="number">0</span>;</span><br><span class="line">sscanf_s(szBuffer, <span class="string">&quot;%d&quot;</span>, &amp;dwHandle);</span><br><span class="line">printf_s(<span class="string">&quot;%s\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">printf_s(<span class="string">&quot;%d\n&quot;</span>, dwHandle);</span><br><span class="line"></span><br><span class="line">HANDLE g_hEvent = (HANDLE)dwHandle;</span><br><span class="line">printf_s(<span class="string">&quot;.....开始等待\n&quot;</span>);</span><br><span class="line">WaitForSingleObject(g_hEvent, INFINITE);</span><br><span class="line">DWORD dwCode = GetLastError();</span><br><span class="line">printf_s(<span class="string">&quot;%d\n&quot;</span>, dwCode);</span><br><span class="line">printf_s(<span class="string">&quot;等到消息.....\n&quot;</span>);</span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路就是进程A创建出一个可继承的事件，然后进程A创建出进程B，并且让进程B继承进程A的句柄表，此时B的句柄表中就就有A创建的事件的句柄，A创建B时又是通过命令行传参，此时B就可以通过参数获得事件的句柄，然后存到g_hEvent当中，接下来就是等待线程A将事件设置成已通知了。然后B就可以进行往下执行了</p><p><img src="/./../images/image-20240916224020671.png" alt="image-20240916224020671"></p><p>可以看到已经输出了等待到消息，可以说明进程B继承了A的句柄表</p><p><strong>注意：</strong> 这里参数传递有个坑，当我们要用sscanf将g_hEvent传到szBuffer中，里面如果用”%d”，则线程B中获取sprintf中的占位符也要用”%d”</p><p>形象化：</p><p><img src="/./../images/image-20240916224324742.png" alt="image-20240916224324742"></p><p><img src="/./../images/image-20240916224335478.png" alt="image-20240916224335478"></p><p><img src="/./../images/image-20240916224345497.png" alt="image-20240916224345497"></p>]]></content>
      
      
      <categories>
          
          <category> 滴水三期 </category>
          
          <category> win32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滴水三期 </tag>
            
            <tag> win32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12.win32事件</title>
      <link href="/2024/09/15/win32%E4%BA%8B%E4%BB%B6/"/>
      <url>/2024/09/15/win32%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="内核对象"><a href="#内核对象" class="headerlink" title="内核对象"></a>内核对象</h1><hr><hr><h2 id="1、什么是内核对象"><a href="#1、什么是内核对象" class="headerlink" title="1、什么是内核对象"></a>1、什么是内核对象</h2><hr><p><img src="/../images/1.png" alt="avater"></p><h3 id="内核对象："><a href="#内核对象：" class="headerlink" title="内核对象："></a>内核对象：</h3><ul><li>进程</li><li>线程</li><li>文件</li><li>文件映射</li><li>事件</li><li>互斥体等待</li></ul><h2 id="2、事件内核创建"><a href="#2、事件内核创建" class="headerlink" title="2、事件内核创建"></a>2、事件内核创建</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HANDLE <span class="title function_">CreateEventA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in, optional] LPSECURITY_ATTRIBUTES lpEventAttributes,</span></span><br><span class="line"><span class="params">  [in]           BOOL                  bManualReset,</span></span><br><span class="line"><span class="params">  [in]           BOOL                  bInitialState,</span></span><br><span class="line"><span class="params">  [in, optional] LPCSTR                lpName</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建事件内核对象</span></span><br><span class="line">HANDLE g_hEvent = CreateEvent(<span class="literal">NULL</span>,TRUE,FALSE,<span class="string">&quot;XYZ&quot;</span>);</span><br><span class="line"><span class="comment">// 创建互斥体对象</span></span><br><span class="line">HANDLE g_hMutex = CreateMutex(<span class="literal">NULL</span>,FALSE,<span class="string">&quot;XYZ&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>CreateEvent</code> 函数参数解释：</p><ul><li><code>lpEventAttributes</code> : 安全属性</li><li><code>bManualReset</code> : 如果值为TRUE，在获取事件对象后要手动设置未通知；如果为FALSE，则自动变成未通知</li><li><code>bInitialState</code> : 设置事件初始发送信号的状态，TRUE为初始已通知，FALSE为初始未通知</li><li><code>lpName</code> : 事件对象的名称。(只用在进程间才需要用到)</li></ul><h2 id="3、事件内核对象的获取"><a href="#3、事件内核对象的获取" class="headerlink" title="3、事件内核对象的获取"></a>3、事件内核对象的获取</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HANDLE <span class="title function_">OpenEvent</span><span class="params">(</span></span><br><span class="line"><span class="params">DWORD dwDesiredAccess,    <span class="comment">// access</span></span></span><br><span class="line"><span class="params">BOOL bInheritHandle,      <span class="comment">// ingeritance option</span></span></span><br><span class="line"><span class="params">LPCTSTR lpName            <span class="comment">// object name</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件内核对象的获取</span></span><br><span class="line">HANDLE g_hEvent = OpenEvent(EVENT_ALL_ACCESS , FALSE,<span class="string">&quot;XYZ&quot;</span>);</span><br><span class="line"><span class="comment">// 互斥体内核对象的获取</span></span><br><span class="line">HANDLE g_hMutex = OpenMutex(MUTEX_ALL_ACCESS,FALSE,<span class="string">&quot;XYZ&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="4、内核对象的销毁"><a href="#4、内核对象的销毁" class="headerlink" title="4、内核对象的销毁"></a>4、内核对象的销毁</h2><hr><p><code>BOOL CloseHandle(HANDLE hobj);</code></p><ol><li>当没有其他程序引用时，系统会销毁内核对象（使用数量）</li><li>内核对象的生命周期，可能比创建它的对象要长</li></ol><h3 id="实验验证："><a href="#实验验证：" class="headerlink" title="实验验证："></a>实验验证：</h3><p>进程一创建内核对象，进程二获取内核对象，进程一销毁内核对象，进程三依旧可以获取内核对象，通俗个人理解：因为有两个人在使用，一个人销毁了，还有另外一个人可以找</p><ul><li>首先要明白<strong>计数器</strong>的概念，在高2g内存(内核)有一个结构体存储着这些参数，进程一创建对象，计数器+1，进程二获取对象，计数器+1，进程一销毁对象，计数器-1，所以当进程三去获取内核对象时，计数器里面还剩1个可以获取</li></ul><h1 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h1><hr><hr><h2 id="1、事件对象的创建"><a href="#1、事件对象的创建" class="headerlink" title="1、事件对象的创建"></a>1、事件对象的创建</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HANDLE <span class="title function_">CreateEvent</span><span class="params">(</span></span><br><span class="line"><span class="params">LPSECURITY_ATTRIBUTES lpEventAttributes,      <span class="comment">// 安全属性 NULL时为系统默认</span></span></span><br><span class="line"><span class="params">BOOL bManualReset,                            <span class="comment">// TRUE 通过调用ResetEvent将事件对象标记为未通知</span></span></span><br><span class="line"><span class="params">BOOL bInitialState,                           <span class="comment">// TRUE 已通知状态 FALSE未通知状态（初始）</span></span></span><br><span class="line"><span class="params">LPCTSTR lpName                                <span class="comment">// 对象名称，以NULL结尾的字符串</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><h2 id="2、事件对象的控制"><a href="#2、事件对象的控制" class="headerlink" title="2、事件对象的控制"></a>2、事件对象的控制</h2><hr><p><code>BOOL SetEvent(HANDLE hEvent);</code>  &#x2F;&#x2F; 将对象设置为已通知</p><h3 id="对已通知、未通知的理解："><a href="#对已通知、未通知的理解：" class="headerlink" title="对已通知、未通知的理解："></a>对已通知、未通知的理解：</h3><p>简单来说就是未通知时，不会发出信号，其他线程会在WaitForSingleObject的作用下阻塞，当对象变成已通知时，获取到对象的线程才能通过WaitForSingleObject进行执行下去</p><h2 id="3、线程控制实验：只读形式的线程控制"><a href="#3、线程控制实验：只读形式的线程控制" class="headerlink" title="3、线程控制实验：只读形式的线程控制"></a>3、线程控制实验：只读形式的线程控制</h2><hr><h3 id="实验一："><a href="#实验一：" class="headerlink" title="实验一："></a>实验一：</h3><p><code>CreateEvent</code> 的第二个参数设置成TRUE，即要手动设置成未通知</p><p>ThreadMain线程函数：</p><p><img src="/./../images/image-20240915190756532.png" alt="image-20240915190756532"></p><p>其他三个线程，开始时用WaitForSingleObject阻塞住：</p><p><img src="/./../images/image-20240915190825087.png" alt="image-20240915190825087"></p><p>当Thread1程序跑到<code>SetEvent</code>后，三个文本框同时出现1000，主线程里修改对象状态为已通知时，第一个线程wait到了，执行完后状态依旧是已通知（因为我们第二个参数为TRUE，需要手动使用设置成未通知），所以三个编辑框都可以读取到</p><p><img src="/./../images/image-20240915190845413.png" alt="image-20240915190845413"></p><h3 id="实验二："><a href="#实验二：" class="headerlink" title="实验二："></a>实验二：</h3><p><code>CreateEvent</code> 的第二个参数设置成FALSE，即Wait后自动设置成未通知</p><p>此时其他线程在函数执行完的位置要加上SetEvent(hEvent);来将事件对象设置成已通知</p><p><img src="/./../images/image-20240915190855897.png" alt="image-20240915190855897"></p><p>执行代码，下面三个文本框是一个一个变成1000的，因为设置成FALSE后当线程wait到事件对象时就会自动设置成未通知状态，其他线程就无法使用，得等到我这个线程用完并用SetEvent将其设置成已通知其他线程才能用，从而可以实现互斥</p><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><hr><h2 id="1、什么是线程同步？"><a href="#1、什么是线程同步？" class="headerlink" title="1、什么是线程同步？"></a>1、什么是线程同步？</h2><hr><h3 id="线程同步："><a href="#线程同步：" class="headerlink" title="线程同步："></a>线程同步：</h3><p>通俗来讲就是两个或以上的线程运行要严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。按预定的先后次序运行。比如 A 任务的运行依赖于 B 任务产生的数据。</p><h3 id="线程互斥："><a href="#线程互斥：" class="headerlink" title="线程互斥："></a>线程互斥：</h3><p>与线程同步不同，线程互斥只是当这个线程运行时，其他线程不能运行，得等到我这个线程运行完才能执行，没有顺序要求</p><h2 id="2、代码实验"><a href="#2、代码实验" class="headerlink" title="2、代码实验"></a>2、代码实验</h2><hr><p>实现两个线程严格的交替输出。<br>首先先用互斥或者临界区来看看能不能实现：<br>代码1（临界区）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">CRITICAL_SECTION g_cs;</span><br><span class="line"><span class="type">int</span> g_Max = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> g_Number = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//生产者线程函数  </span></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadProduct</span><span class="params">(LPVOID pM)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g_Max; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//互斥的访问缓冲区  </span></span><br><span class="line">EnterCriticalSection(&amp;g_cs);</span><br><span class="line">g_Number = <span class="number">1</span>;</span><br><span class="line">DWORD id = GetCurrentThreadId();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;生产者%d将数据%d放入缓冲区\n&quot;</span>, id, g_Number);</span><br><span class="line">LeaveCriticalSection(&amp;g_cs);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者线程函数</span></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadConsumer</span><span class="params">(LPVOID pM)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g_Max; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//互斥的访问缓冲区  </span></span><br><span class="line">EnterCriticalSection(&amp;g_cs);</span><br><span class="line">g_Number = <span class="number">0</span>;</span><br><span class="line">DWORD id = GetCurrentThreadId();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----消费者%d将数据%d放入缓冲区\n&quot;</span>, id, g_Number);</span><br><span class="line">LeaveCriticalSection(&amp;g_cs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">InitializeCriticalSection(&amp;g_cs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HANDLE hThread[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">hThread[<span class="number">0</span>] = ::CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProduct, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">hThread[<span class="number">1</span>] = ::CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadConsumer, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">WaitForMultipleObjects(<span class="number">2</span>, hThread, TRUE, INFINITE);</span><br><span class="line">CloseHandle(hThread[<span class="number">0</span>]);</span><br><span class="line">CloseHandle(hThread[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁 </span></span><br><span class="line">DeleteCriticalSection(&amp;g_cs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="/./../images/image-20240915190909087.png" alt="image-20240915190909087"></p><p>代码2（互斥体）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hMutex;</span><br><span class="line"><span class="type">int</span> g_Max = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> g_Number = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//生产者线程函数  </span></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadProduct</span><span class="params">(LPVOID pM)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g_Max; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//互斥的访问缓冲区  </span></span><br><span class="line">WaitForSingleObject(hMutex, INFINITE);</span><br><span class="line">g_Number = <span class="number">1</span>;</span><br><span class="line">DWORD id = GetCurrentThreadId();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;生产者%d将数据%d放入缓冲区\n&quot;</span>, id, g_Number);</span><br><span class="line">ReleaseMutex(hMutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者线程函数</span></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadConsumer</span><span class="params">(LPVOID pM)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g_Max; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//互斥的访问缓冲区  </span></span><br><span class="line">WaitForSingleObject(hMutex, INFINITE);</span><br><span class="line">g_Number = <span class="number">0</span>;</span><br><span class="line">DWORD id = GetCurrentThreadId();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----消费者%d将数据%d放入缓冲区\n&quot;</span>, id, g_Number);</span><br><span class="line">ReleaseMutex(hMutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建一个互斥体</span></span><br><span class="line">hMutex = CreateMutex(<span class="literal">NULL</span>, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">HANDLE hThread[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">hThread[<span class="number">0</span>] = ::CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProduct, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">hThread[<span class="number">1</span>] = ::CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadConsumer, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">WaitForMultipleObjects(<span class="number">2</span>, hThread, TRUE, INFINITE);</span><br><span class="line">CloseHandle(hThread[<span class="number">0</span>]);</span><br><span class="line">CloseHandle(hThread[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁 </span></span><br><span class="line">CloseHandle(hMutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="/./../images/20240912215204.png" alt="Pasted image 20240912215204"></p><p>发现不管时临界区，还是互斥体都无法实现严格的交替输出，这时，我们就可以用事件来实现。</p><blockquote><p>事件是可以自动设置成未通知，然后通过SetEvent来设置成已通知的，对于两个线程，我们就可以通过两个事件来实现线程同步，具体代码如下:</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hEvent1,hEvent2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadProc1</span><span class="params">(LPVOID lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">WaitForSingleObject(hEvent1, INFINITE);</span><br><span class="line">DWORD id = GetCurrentThreadId();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;生产者 %d 将数据 1 放入缓冲区\n&quot;</span>,id);</span><br><span class="line">SetEvent(hEvent2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadProc2</span><span class="params">(LPVOID lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">WaitForSingleObject(hEvent2, INFINITE);</span><br><span class="line">DWORD id = GetCurrentThreadId();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----消费者 %d 将数据 1 取出缓冲区\n&quot;</span>,id);</span><br><span class="line">SetEvent(hEvent1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">HANDLE hThread[<span class="number">2</span>];</span><br><span class="line">hThread[<span class="number">0</span>] = ::CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc1, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">hThread[<span class="number">1</span>] = ::CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc2, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">hEvent1 = CreateEvent(<span class="literal">NULL</span>, FALSE, TRUE, <span class="literal">NULL</span>);</span><br><span class="line">hEvent2 = CreateEvent(<span class="literal">NULL</span>, FALSE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">WaitForMultipleObjects(<span class="number">2</span>, hThread, TRUE, INFINITE);</span><br><span class="line">CloseHandle(hThread[<span class="number">0</span>]);</span><br><span class="line">CloseHandle(hThread[<span class="number">1</span>]);</span><br><span class="line">CloseHandle(hEvent1);</span><br><span class="line">CloseHandle(hEvent2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到输出已经是严格交替了：</p><p><img src="/./../images/image-20240915190925802.png" alt="image-20240915190925802"></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><hr><ol><li>线程同步的实现：可以用事件来实现，有几个线程就创建多少个事件对象，全部都设置成自动变成未通知状态，第一个启动的线程要在将事件对象的初始状态设置成已通知，然后通过一个线程控制另一个线程的启动。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 滴水三期 </category>
          
          <category> win32 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
